/*
 * generated by Xtext 2.17.1
 */
package fr.n7.serializer;

import com.google.inject.Inject;
import fr.n7.jEU.AllocateurConnaissance;
import fr.n7.jEU.AllocateurObjet;
import fr.n7.jEU.Chemin;
import fr.n7.jEU.Connaissance;
import fr.n7.jEU.Interaction;
import fr.n7.jEU.JEUPackage;
import fr.n7.jEU.Jeu;
import fr.n7.jEU.Joueur;
import fr.n7.jEU.Lieu;
import fr.n7.jEU.Objet;
import fr.n7.jEU.Personne;
import fr.n7.jEU.action;
import fr.n7.jEU.choix;
import fr.n7.jEU.condition;
import fr.n7.services.JEUGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class JEUSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private JEUGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == JEUPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case JEUPackage.ALLOCATEUR_CONNAISSANCE:
				sequence_AllocateurConnaissance(context, (AllocateurConnaissance) semanticObject); 
				return; 
			case JEUPackage.ALLOCATEUR_OBJET:
				sequence_AllocateurObjet(context, (AllocateurObjet) semanticObject); 
				return; 
			case JEUPackage.CHEMIN:
				sequence_Chemin(context, (Chemin) semanticObject); 
				return; 
			case JEUPackage.CONNAISSANCE:
				sequence_Connaissance(context, (Connaissance) semanticObject); 
				return; 
			case JEUPackage.INTERACTION:
				sequence_Interaction(context, (Interaction) semanticObject); 
				return; 
			case JEUPackage.JEU:
				sequence_Jeu(context, (Jeu) semanticObject); 
				return; 
			case JEUPackage.JOUEUR:
				sequence_Joueur(context, (Joueur) semanticObject); 
				return; 
			case JEUPackage.LIEU:
				sequence_Lieu(context, (Lieu) semanticObject); 
				return; 
			case JEUPackage.OBJET:
				sequence_Objet(context, (Objet) semanticObject); 
				return; 
			case JEUPackage.PERSONNE:
				sequence_Personne(context, (Personne) semanticObject); 
				return; 
			case JEUPackage.ACTION:
				sequence_action(context, (action) semanticObject); 
				return; 
			case JEUPackage.CHOIX:
				sequence_choix(context, (choix) semanticObject); 
				return; 
			case JEUPackage.CONDITION:
				sequence_condition(context, (condition) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AllocateurConnaissance returns AllocateurConnaissance
	 *
	 * Constraint:
	 *     (connaissanceAlloue=[Connaissance|ID] (estConditionne?='condition' conditionAllocution=condition)?)
	 */
	protected void sequence_AllocateurConnaissance(ISerializationContext context, AllocateurConnaissance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AllocateurObjet returns AllocateurObjet
	 *
	 * Constraint:
	 *     (objetAlloue=[Objet|ID] consomme?='consomme'? quantite=INT (estConditionne?='condition' conditionAllocution=condition)?)
	 */
	protected void sequence_AllocateurObjet(ISerializationContext context, AllocateurObjet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JeuElement returns Chemin
	 *     Chemin returns Chemin
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         source=[Lieu|ID] 
	 *         destination=[Lieu|ID] 
	 *         ouvertOUferme=ouvertOuferme 
	 *         visibilite=typevisibilite 
	 *         acces=condition? 
	 *         visible=condition? 
	 *         description=STRING? 
	 *         (allocateursConnaissance+=AllocateurConnaissance allocateursConnaissance+=AllocateurConnaissance*)? 
	 *         (allocateursObjetLieu+=AllocateurObjet allocateursObjetLieu+=AllocateurObjet*)?
	 *     )
	 */
	protected void sequence_Chemin(ISerializationContext context, Chemin semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JeuElement returns Connaissance
	 *     Connaissance returns Connaissance
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         visibilite=typevisibilite 
	 *         activite=typeactivite 
	 *         estPossede?='possede'? 
	 *         acces=condition? 
	 *         visible=condition? 
	 *         description=STRING?
	 *     )
	 */
	protected void sequence_Connaissance(ISerializationContext context, Connaissance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Interaction returns Interaction
	 *
	 * Constraint:
	 *     (personne=[Personne|ID] question=STRING choix+=choix choix+=choix* choixJoueur+=choix)
	 */
	protected void sequence_Interaction(ISerializationContext context, Interaction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Jeu returns Jeu
	 *
	 * Constraint:
	 *     (name=ID joueur=Joueur (jeuelement+=JeuElement jeuelement+=JeuElement*)?)
	 */
	protected void sequence_Jeu(ISerializationContext context, Jeu semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Joueur returns Joueur
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (connaissance+=[Connaissance|ID] connaissance+=[Connaissance|ID]*)? 
	 *         tailleinventaire=INT 
	 *         (objets+=[Objet|ID] objets+=[Objet|ID]*)? 
	 *         lieu=[Lieu|ID]
	 *     )
	 */
	protected void sequence_Joueur(ISerializationContext context, Joueur semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JeuElement returns Lieu
	 *     Lieu returns Lieu
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         type=typeLieu 
	 *         description=STRING? 
	 *         (connaissance+=Connaissance connaissance+=Connaissance*)? 
	 *         (objetslieu+=Objet objetslieu+=Objet*)? 
	 *         (personnes+=Personne personnes+=Personne*)?
	 *     )
	 */
	protected void sequence_Lieu(ISerializationContext context, Lieu semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JeuElement returns Objet
	 *     Objet returns Objet
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         taille=INT 
	 *         quantite=INT 
	 *         visibilite=typevisibilite 
	 *         activite=typeactivite 
	 *         (dansLieu?='danslelieu' lieu=[Lieu|ID] conditionDeposer=condition?)? 
	 *         description=STRING?
	 *     )
	 */
	protected void sequence_Objet(ISerializationContext context, Objet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Personne returns Personne
	 *
	 * Constraint:
	 *     (name=ID visibilite=typevisibilite activite=typeactivite interaction=Interaction)
	 */
	protected void sequence_Personne(ISerializationContext context, Personne semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JEUPackage.Literals.PERSONNE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JEUPackage.Literals.PERSONNE__NAME));
			if (transientValues.isValueTransient(semanticObject, JEUPackage.Literals.PERSONNE__VISIBILITE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JEUPackage.Literals.PERSONNE__VISIBILITE));
			if (transientValues.isValueTransient(semanticObject, JEUPackage.Literals.PERSONNE__ACTIVITE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JEUPackage.Literals.PERSONNE__ACTIVITE));
			if (transientValues.isValueTransient(semanticObject, JEUPackage.Literals.PERSONNE__INTERACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JEUPackage.Literals.PERSONNE__INTERACTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPersonneAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPersonneAccess().getVisibiliteTypevisibiliteEnumRuleCall_4_0(), semanticObject.getVisibilite());
		feeder.accept(grammarAccess.getPersonneAccess().getActiviteTypeactiviteEnumRuleCall_6_0(), semanticObject.getActivite());
		feeder.accept(grammarAccess.getPersonneAccess().getInteractionInteractionParserRuleCall_8_0(), semanticObject.getInteraction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     action returns action
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         description=STRING? 
	 *         (allocateursConnaissance+=AllocateurConnaissance allocateursConnaissance+=AllocateurConnaissance*)? 
	 *         (allocateursObjetLieu+=AllocateurObjet allocateursObjetLieu+=AllocateurObjet*)? 
	 *         conditionAction=condition? 
	 *         choixSuivants+=choix? 
	 *         estFinale?='finale'?
	 *     )
	 */
	protected void sequence_action(ISerializationContext context, action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     choix returns choix
	 *
	 * Constraint:
	 *     (name=ID description=STRING? (actions+=action actions+=action*)? (estFin?='fin' conditionFin=condition?)?)
	 */
	protected void sequence_choix(ISerializationContext context, choix semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     condition returns condition
	 *
	 * Constraint:
	 *     (name=ID ((Objet=[Objet|ID] comparaison=Comparateur reference=INT) | (Connaissance=[Connaissance|ID] presente?='presente'?)))
	 */
	protected void sequence_condition(ISerializationContext context, condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
